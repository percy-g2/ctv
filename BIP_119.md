# BIP 119: CHECKTEMPLATEVERIFY

**Author:** Jeremy Rubin  
**Status:** Draft  
**Type:** Standards Track  
**Created:** 2019-01-06  
**License:** BSD-2-Clause

---

## Abstract

This BIP proposes a new opcode, `OP_CHECKTEMPLATEVERIFY` (also known as CTV), that allows for the creation of covenants in Bitcoin Script. Covenants are restrictions on how bitcoins can be spent in the future. `OP_CHECKTEMPLATEVERIFY` enables non-recursive, fully enumerated covenants with no dynamic state, providing a mechanism to commit to a specific transaction template.

## Motivation

Bitcoin Script currently lacks the ability to create covenantsâ€”restrictions on how bitcoins can be spent in the future. This limitation prevents the implementation of various advanced use cases such as:

- **Congestion Control**: Pre-committing to transaction structures to reduce on-chain congestion
- **Vaults**: Creating time-locked vaults with multiple spend paths (cold storage vs. hot wallet)
- **Payment Channels**: Non-interactive payment channels and improved Lightning Network functionality
- **Self-Custody Solutions**: Enhanced security models for self-custody wallets
- **Layer-2 Applications**: Support for advanced layer-2 protocols like Ark

`OP_CHECKTEMPLATEVERIFY` addresses these limitations by allowing scripts to enforce that a spending transaction matches a predefined template structure.

## Specification

### Opcode Details

**Opcode Name:** `OP_CHECKTEMPLATEVERIFY`  
**Opcode Value:** `0xb3` (179)  
**Opcode Hex:** `0xb3`  
**Function:** Verifies that the spending transaction matches a predefined template

### Stack Operations

When `OP_CHECKTEMPLATEVERIFY` is executed:

1. **Stack Check**: Verifies that there is at least one element on the stack. If the stack is empty, the script fails.

2. **Size Verification**: Checks that the top stack element is exactly 32 bytes. If the element is not 32 bytes, the opcode acts as a no-operation (NOP) and execution continues.

3. **Hash Comparison**: 
   - Computes the `DefaultCheckTemplateVerifyHash` for the current input index
   - Compares this hash to the 32-byte value on the stack
   - If they match, execution continues successfully
   - If they do not match, the script fails

### DefaultCheckTemplateVerifyHash Calculation

The `DefaultCheckTemplateVerifyHash` commits to specific fields of the spending transaction to ensure it adheres to the predefined template. The hash is computed using SHA256 over the following fields:

1. **nVersion** (4 bytes): Transaction version number
2. **nLocktime** (4 bytes): Locktime indicating the earliest time a transaction can be included in a block
3. **Input Count** (varint): Number of inputs in the transaction
4. **Sequences Hash** (32 bytes): SHA256 hash of all input sequence numbers concatenated together
5. **Output Count** (varint): Number of outputs in the transaction
6. **Outputs Hash** (32 bytes): SHA256 hash of all outputs (scriptPubKey + amount) concatenated together
7. **Input Index** (varint): Index of the current input being processed

The hash is computed as:
```
DefaultCheckTemplateVerifyHash = SHA256(
    nVersion || 
    nLocktime || 
    InputCount || 
    SequencesHash || 
    OutputCount || 
    OutputsHash || 
    InputIndex
)
```

### Standardness Rules

To maintain network stability and prevent unintended behaviors, the following standardness rules are recommended:

- **Non-32-byte Stack Elements**: Should be rejected with the error `SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS` to discourage upgradable NOPs and ensure only properly formatted templates are accepted.

### Script Usage Pattern

A typical CTV locking script follows this pattern:

```
<32-byte CTV hash> OP_CHECKTEMPLATEVERIFY
```

Or in hex:
```
4c20<32-byte-hash>b3
```

Where:
- `4c20` is `OP_PUSHDATA1` followed by `0x20` (32 bytes)
- `<32-byte-hash>` is the 32-byte CTV hash
- `b3` is `OP_CHECKTEMPLATEVERIFY`

### Example: Simple CTV Lock

```python
# Create a CTV hash committing to specific outputs
ctv_hash = calculate_ctv_hash(
    version=1,
    locktime=0,
    sequences=[0],
    outputs=[
        {"scriptPubKey": "76a914...", "amount": 100000},
        {"scriptPubKey": "76a914...", "amount": 50000}
    ],
    input_index=0
)

# Create locking script
locking_script = bytes([0x4c, 0x20]) + ctv_hash + bytes([0xb3])
```

## Use Cases

### 1. Congestion Control

CTV enables congestion control by pre-committing to transaction structures. Users can create CTV locks that commit to specific output structures, reducing on-chain congestion by allowing batched transactions.

### 2. Vaults

CTV vaults provide enhanced security for self-custody solutions:

- **Cold Storage Path**: Immediate spend to a cold storage address (no delay)
- **Hot Wallet Path**: Delayed spend to a hot wallet address (requires block delay)

This allows users to create vaults with multiple spend paths, improving security while maintaining usability.

### 3. Payment Channels

CTV enables non-interactive payment channels and improves Lightning Network functionality by allowing pre-commitment to channel structures.

### 4. Layer-2 Applications

CTV supports advanced layer-2 protocols like Ark, enabling more sophisticated transaction types and improving scalability.

## Security Considerations

### Non-Recursive Covenants

`OP_CHECKTEMPLATEVERIFY` creates non-recursive covenants. Once funds are spent from a CTV lock, they cannot be re-locked into another CTV structure without explicit consent. This prevents infinite recursion and maintains Bitcoin's fungibility.

### No Dynamic State

CTV covenants are fully enumerated with no dynamic state. All possible spend paths must be known at the time the CTV hash is created. This provides predictability and security.

### Script Validation

The opcode validates the entire transaction structure, ensuring that:
- Transaction version matches
- Locktime matches
- Input count matches
- Sequence numbers match
- Output count matches
- Outputs (addresses and amounts) match exactly

## Implementation Status

As of 2025, BIP 119 has gained significant support within the Bitcoin development community:

- **Proposal Date**: January 2019
- **Status**: Draft (pending activation)
- **Community Support**: 66+ Bitcoin developers and contributors have signed an open letter supporting BIP 119 and related proposals
- **Activation**: Requires decentralized community consensus through Bitcoin's governance process

## Related BIPs

- **BIP 348**: Related proposal for enhanced Bitcoin scripting capabilities
- **BIP 118**: SIGHASH_ANYPREVOUT (related covenant functionality)

## References

- **Official BIP Repository**: https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki
- **Bitcoin Inquisition**: https://github.com/bitcoin-inquisition/bitcoin (testnet implementation)
- **Author's GitHub**: https://github.com/JeremyRubin

## Acknowledgments

**Author:** Jeremy Rubin  
**Contributors:** The Bitcoin development community  
**Reviewers:** Jameson Lopp, Andrew Poelstra, and 64+ other Bitcoin developers and contributors

---

## License

This BIP is licensed under the BSD-2-Clause license.

---

*This document provides a comprehensive overview of BIP 119 (CHECKTEMPLATEVERIFY). For the most up-to-date specification, please refer to the official BIP repository on GitHub.*
